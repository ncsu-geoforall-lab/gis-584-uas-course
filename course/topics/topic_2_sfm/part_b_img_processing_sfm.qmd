---
Topic: "Topic 2: Structure from Motion"
title: "B. Imagery processing and structure from motion (SfM)"
subtitle: "Topic 2: Structure from Motion"
date: 8/28/2024
"Assignment Due Date": 9/30/2024
---

# From images to 3D models: Photogrammetry and Structure from Motion concepts

## Outline

* aerial imagery distortions
* orthorectification process
* interior and exterior orientation
* Bundle Block Adjustment
* Ground control points (GCP)
* Image mosaic and point cloud results
* Structure from motion (SfM)

## Lecture

* Lecture Slides: [Photogrammetry and SfM](lectures/lecture_2b.qmd)
* Lecture Recording: [Fall 2024]({{< var recordings.topic2.lecture2b >}}) (NCSU Only)

##  Supplemental materials

* Lectures and demos from the 2021 Geological Society of America short course: 
    * ["Introduction to Structure from Motion Photogrammetry"](https://opentopography.org/workshops/GSA2021)
    * [OpenTopography YouTube Course](https://www.youtube.com/playlist?list=PLYqCeHIaz7Pi2jpqsROsk064vmOsMPz9v)

* Y. Furukawa and C. Hernández . [Multi-View Stereo: A Tutorial](http://carlos-hernandez.org/papers/fnt_mvs_2015.pdf). Foundations and TrendsR in Computer Graphics and Vision, vol. 9, no. 1-2, pp. 1–148, 2013.

## Assignment
<!-- TODO: Update Links -->
<!-- * [Intro to the assignment (slides)](https://ncsu-geoforall-lab.github.io/uav-lidar-analytics-course/lectures/2017_Imagery_Processing_assignment_intro.html#/) -->
* [Geoprocessing UAS imagery in Agisoft Metashape](assignments/assignment_2b.qmd)

## Homework

Prepare report on generating orthomosaic and Digital Surface Model using images taken by the UAS Trimble UX5 Rover and performing the processing in Agisoft Metashape. Explain the report generated by Agisoft including the data accuracy.

## Structure from Motion Example

```{html}
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structure from Motion Visualization - Correctly Positioned Anchor Points</title>
    <style>
        /* body {
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            /* background-color: #000; */
        } */

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script> -->
    <script>

        // Create a GUI
        // const gui = new dat.GUI();

        // Parameters object
        const params = {
            numAnchorPoints: 10, // Default number of anchor points
            terrainSize: 100 // Default terrain size
        };

        // Add controls to the GUI
        // gui.add(params, 'numAnchorPoints', 1, 100).name('Anchor Points').onChange(updateAnchorPoints);
        // gui.add(params, 'terrainSize', 10, 500).name('Terrain Size').onChange(updateTerrain);

        // Function to update anchor points
        // function updateAnchorPoints(value) {
        //     // Logic to update the number of anchor points
        //     // For example, regenerate anchor points based on the new value
        //     anchorPoints = createAnchorPoints(geometry, value, terrain);
        // }

        // // Function to update terrain
        // function updateTerrain(value) {
        //     // Logic to update the terrain size
        //     // For example, regenerate the terrain based on the new value
        //     generateTerrain(value);
        // }

        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5).normalize();
        scene.add(directionalLight);

        // Simplex noise instance
        const simplex = new SimplexNoise();

        // Create a DSM using PlaneBufferGeometry and subtle simplex noise
        const widthSegments = 100;
        const heightSegments = 100;
        const geometry = new THREE.PlaneBufferGeometry(10, 10, widthSegments, heightSegments);

        // Modify the z-coordinates of the vertices using simplex noise with reduced amplitude
        const vertices = geometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const y = vertices[i + 1];
            vertices[i + 2] = simplex.noise2D(x * 0.3, y * 0.3) / 2.0; // Reduced amplitude for a more subtle terrain
        }

        const elevationColors = [
            { value: 0.0, color: new THREE.Color(0x00bfbf) }, // 0% 0 191 191
            { value: 0.2, color: new THREE.Color(0x00ff00) }, // 20% 0 255 0
            { value: 0.4, color: new THREE.Color(0xffff00) }, // 40% 255 255 0
            { value: 0.6, color: new THREE.Color(0xff7f00) }, // 60% 255 127 0
            { value: 0.8, color: new THREE.Color(0xbf7f3f) }, // 80% 191 127 63
            { value: 1.0, color: new THREE.Color(0xc8c8c8) }  // 100% 200 200 200
        ];

        const vertexShader = `
            varying float vElevation;
            void main() {
                vElevation = position.z;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec3 elevationColors[3];
            varying float vElevation;
            void main() {
                vec3 color;
                if (vElevation < 0.5) {
                    color = mix(elevationColors[0], elevationColors[1], vElevation * 2.0);
                } else {
                    color = mix(elevationColors[1], elevationColors[2], (vElevation - 0.5) * 2.0);
                }
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        geometry.computeVertexNormals(); // Recompute normals after modifying vertices

        // Colored Terrain
        // const shaderMaterial = new THREE.ShaderMaterial({
        //     vertexShader: vertexShader,
        //     fragmentShader: fragmentShader,
        //     uniforms: {
        //         elevationColors: { value: elevationColors.map(e => e.color) }
        //     }
        // });
        // const terrain = new THREE.Mesh(geometry, shaderMaterial);

        // Wired Terrain
        const material = new THREE.MeshStandardMaterial({ color: 0x228b22, wireframe: true });
        const terrain = new THREE.Mesh(geometry, material);

        
        terrain.rotation.x = -Math.PI / 2; // Rotate to make it horizontal
        scene.add(terrain);

        // Function to create anchor points directly on the DSM's surface
        function createAnchorPoints(bufferGeometry, numPoints, terrain) {
            const positions = bufferGeometry.attributes.position.array;
            const points = [];

            for (let i = 0; i < numPoints; i++) {
                // Randomly select a vertex from the geometry
                const index = Math.floor(Math.random() * (positions.length / 3)) * 3;

                // Create a point at this vertex
                const point = new THREE.Vector3(
                    positions[index],
                    positions[index + 1],
                    positions[index + 2]
                );

                // Apply the terrain's rotation to the anchor points
                point.applyMatrix3(terrain.matrixWorld);

                points.push(point);
            }
            return points;
        }

        // Correctly place anchor points on the terrain surface after rotation
        const anchorPoints = createAnchorPoints(geometry, 50, terrain);
        const anchorMaterial = new THREE.PointsMaterial({ color: 0xff0000, size: 0.25 });
        const anchorGeometry = new THREE.BufferGeometry().setFromPoints(anchorPoints);

        const anchorMesh = new THREE.Points(anchorGeometry, anchorMaterial);
        scene.add(anchorMesh);

        // Function to create a camera representation
        function createCameraRepresentation(position, color = 0x0000ff) {
            const cameraGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const cameraMaterial = new THREE.MeshBasicMaterial({ color });
            const cameraMesh = new THREE.Mesh(cameraGeometry, cameraMaterial);
            cameraMesh.position.copy(position);
            scene.add(cameraMesh);
            return cameraMesh;
        }

        // Create a UAV camera path for two passes
        // const uavPath1 = [];
        // const uavPath2 = [];
        // for (let i = 0; i <= 1; i += 0.01) {
        //     const x = 5 * (i * 2 - 1);
        //     const z = 5 * (i * 2 - 1);
        //     uavPath1.push(new THREE.Vector3(x, 3, z));
        //     uavPath2.push(new THREE.Vector3(x, 3.5, -z));
        // }

         // Create realistic UAV camera paths (grid pattern)
        // const uavPath1 = [];
        // const uavPath2 = [];
        // for (let i = -5; i <= 5; i += 0.25) {
        //     for (let j = -5; j <= 5; j += 0.25) {
        //         uavPath1.push(new THREE.Vector3(3, 3, j));
        //         uavPath2.push(new THREE.Vector3(i, 3.5, j));
        //     }
        // }const uavCamera2 = createCameraRepresentation(uavPath2[0], 0xff0000);

        // Define the boundaries and step sizes
        const startX = -5;
        const endX = 5;
        const startY = 3;
        const endY = 3;
        const startZ = -5;
        const endZ = 5;
        const stepSize = 0.25;
        const rowDistance = 0.25;

        // Create realistic UAV camera paths (lawnmower pattern)
        const uavPath1 = [];
        const uavPath2 = [];

        let direction = 1; // 1 for forward, -1 for backward

        for (let z = startZ; z <= endZ; z += rowDistance) {
            if (direction === 1) {
                for (let x = startX; x <= endX; x += stepSize) {
                    uavPath1.push(new THREE.Vector3(x, startY, z));
                    uavPath2.push(new THREE.Vector3(x, endY, z));
                }
            } else {
                for (let x = endX; x >= startX; x -= stepSize) {
                    uavPath1.push(new THREE.Vector3(x, startY, z));
                    uavPath2.push(new THREE.Vector3(x, endY, z));
                }
            }
            direction *= -1; // Change direction at the end of each row
        }

        // Create geometry and add points from uavPath1
        const uavlineGeometry = new THREE.BufferGeometry().setFromPoints(uavPath1[0]);

        // Create a dashed line material
        const uavlineMaterial = new THREE.LineDashedMaterial({
            color: 0xff0000, // Red color
            dashSize: 0.1, // Length of dashes
            gapSize: 0.1, // Length of gaps between dashes
        });

        // Create the line object
        const uavLine = new THREE.Line(uavlineGeometry, uavlineMaterial);
        uavLine.computeLineDistances(); // Required for dashed lines

        // Add the line to the scene
        scene.add(uavLine);

        // Create a box to represent the UAV's field of view
        // const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        // const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        // const uavFOVBox = new THREE.Mesh(boxGeometry, boxMaterial);
        // scene.add(uavFOVBox);

        // Create a plane to represent the UAV's field of view
        const planeGeometry = new THREE.PlaneGeometry(2, 2); // Adjust size as needed
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide }); // Solid fill color
        const uavFOVPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        scene.add(uavFOVPlane);

        // // Create a plane to represent the UAV's field of view
        //     const aggPlaneGeometry = new THREE.PlaneGeometry(2, 2); // Adjust size as needed
        //     const aggPlaneMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, wireframe: true }); // Solid fill color
        //     const aggUavFOVPlane = new THREE.Mesh(aggPlaneGeometry, aggPlaneMaterial);
        //     scene.add(aggUavFOVPlane)

        // Define initial position and rotation
        const initialPosition = new THREE.Vector3(0, 0, 0);
        const initialRotation = new THREE.Euler(-Math.PI / 2, 0, 0);

        let uavIndex = 0;
        const uavCamera1 = createCameraRepresentation(uavPath1[0], 0xff0000);
        const uavCamera2 = createCameraRepresentation(uavPath2[0], 0x0000ff);
        

        // Camera frustum visualization for UAV cameras
        const uavFrustum1 = new THREE.CameraHelper(camera);
        const uavFrustum2 = new THREE.CameraHelper(camera);
        scene.add(uavFrustum1);
        scene.add(uavFrustum2);

        // Function to create and return line between two points
        function createLine(pointA, pointB, color = 0xffffff) {
            const geometry = new THREE.BufferGeometry().setFromPoints([pointA, pointB]);
            const material = new THREE.LineBasicMaterial({ color });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            return line;
        }

        // Store the lines for each pass
        const linesPass1 = [];
        const linesPass2 = [];

        // Create lines from the UAV cameras to anchor points
        anchorPoints.forEach(point => {
            linesPass1.push(createLine(uavPath1[0], point, 0xff00ff));
            linesPass2.push(createLine(uavPath2[0], point, 0x00ffff));
        });

        // Simulate feature matching between passes
        function createFeatureMatchingLines(pointsA, pointsB, color = 0xffd700) {
            pointsA.forEach((pointA, index) => {
                const pointB = pointsB[index];
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([pointA, pointB]);
                const lineMaterial = new THREE.LineBasicMaterial({ color });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
            });
        }

        // Create feature matching lines between two UAV passes
        createFeatureMatchingLines(anchorPoints, anchorPoints);

        // OrbitControls for user interaction
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.enableZoom = true;

        camera.position.z = 15;

        let lastUpdateTime = 0;
        const updateInterval = 50; // Time in milliseconds between updates
        function animate(t) {
            requestAnimationFrame(animate);
            // Calculate the time elapsed since the last update
            const elapsedTime = t - lastUpdateTime;

            if (elapsedTime >= updateInterval) {
            // Move the UAV cameras along their paths
            uavIndex = (uavIndex + 1) % uavPath1.length;
            uavCamera1.position.copy(uavPath1[uavIndex]);
            uavCamera2.position.copy(uavPath2[uavIndex]);

            if (uavIndex < uavPath1.length - 1) {
                uavIndex++;
                const newPoints = uavPath1.slice(0, uavIndex + 1);
                uavlineGeometry.setFromPoints(newPoints);
                uavLine.computeLineDistances(); // Required for dashed lines
            }

            // Update the positions of the lines to keep them connected to the moving UAV cameras
            linesPass1.forEach((line, index) => {
                const linePositions = line.geometry.attributes.position.array;
                const anchorPoint = anchorPoints[index];

                // Update the line's start point (UAV camera position)
                linePositions[0] = uavCamera1.position.x;
                linePositions[1] = uavCamera1.position.y;
                linePositions[2] = uavCamera1.position.z;

                // Update the line's endpoint (anchor point on the terrain)
                linePositions[3] = anchorPoint.x;
                linePositions[4] = anchorPoint.y;
                linePositions[5] = anchorPoint.z;

                line.geometry.attributes.position.needsUpdate = true;
            });

            linesPass2.forEach((line, index) => {
                const linePositions = line.geometry.attributes.position.array;
                const anchorPoint = anchorPoints[index];

                // Update the line's start point (UAV camera position)
                linePositions[0] = uavCamera2.position.x;
                linePositions[1] = uavCamera2.position.y;
                linePositions[2] = uavCamera2.position.z;

                // Update the line's endpoint (anchor point on the terrain)
                linePositions[3] = anchorPoint.x;
                linePositions[4] = anchorPoint.y;
                linePositions[5] = anchorPoint.z;

                line.geometry.attributes.position.needsUpdate = true;
            });

            // // Update the UAV's field of view box position
            // uavFOVBox.position.copy(uavCamera1.position);

            //  // Create a plane to represent the UAV's field of view
            const aggPlaneGeometry = new THREE.PlaneGeometry(2, 2); // Adjust size as needed
            const aggPlaneMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, wireframe: true }); // Solid fill color
            const aggUavFOVPlane = new THREE.Mesh(aggPlaneGeometry, aggPlaneMaterial);
            scene.add(aggUavFOVPlane);

            // TODO: Figure out how to reset the aggUavFOVPlane at the end of the uav path
    

            // Update the UAV's field of view plane position and orientation
            aggUavFOVPlane.position.set(uavCamera1.position.x, 0, uavCamera1.position.z); // Set y to 0 to place it on the terrain surface
            aggUavFOVPlane.rotation.x = -Math.PI / 2; // Rotate to align with the terrain surface

            // Update the UAV's field of view plane position and orientation
            uavFOVPlane.position.set(uavCamera1.position.x, 0, uavCamera1.position.z); // Set y to 0 to place it on the terrain surface
            uavFOVPlane.rotation.x = -Math.PI / 2; // Rotate to align with the terrain surface

           
            // Update the last update time
            lastUpdateTime = t;
            }
  
             controls.update();
            renderer.render(scene, camera);
            
        }

        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        animate();
    </script>
</body>
</html>

```



